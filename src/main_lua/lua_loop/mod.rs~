use std::io::{stdout, Stdout,Write, stdin,Read};
use std::{thread::sleep, time::Duration};

use colored::Colorize;
use anyhow::Result;


mod command_string;
mod user_input;

//  //  //  //  //  //  //  //
pub fn enter_loop(_lua: &mlua::Lua, update: &mlua::Function) -> Result<()> {

    //  //  //  //
    if cfg!(test) {
        let update_result: mlua::Table = update.call::<_, mlua::Table>( mlua::Value::Integer(-1) )?;
        let target_pos: mlua::Table = update_result.get("target")?;
        let target_x: i64   = target_pos.get("x")?;
        let target_y: i64   = target_pos.get("y")?;
        println!( "Lua testing\nx={}, y={}", target_x, target_y );
        return Ok(());
    }else{
        let mut update_result: mlua::Table;
        let mut target_pos: mlua::Table;
        let mut target_x: i64;
        let mut target_y: i64;

        /*
        time_step = 1;

        loop {
            update_state_by_lua
            show_state
            get_user_input
            break_if_q
            update_state_by_input
            show_state
            wait_for_continue
        }
        show_exit_result
        */
    }
    //  //  //  //

    loop {
        //call_lua_update()?;
        screen::invoke_redraw( 1, 1 )?;

        // input and converting
        let raw_line = user_input::read_line()?;
            println!("\ninput content: \n<{}>",raw_line.green() );

        let ex_line = command_string::expand( &raw_line)?;
            println!("\nexpanded: \n<{}>",ex_line.blue() );
            sleep( Duration::from_millis(1000) );

        //apply_input()?;
        //break;
        let _ = stdin().read(&mut [0_u8])?;
    }

    //let _ = stdin().read(&mut [0_u8])?;
    //Ok(())
}


